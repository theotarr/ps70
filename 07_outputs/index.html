<!doctype html>
<html lang="en" class="dark">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>PS70 — Week 7: Outputs</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap"
      rel="stylesheet"
    />
    <link href="../dist/output.css" rel="stylesheet" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark-dimmed.min.css"
    />
    <link href="../dist/code-editor.css" rel="stylesheet" />
    <link rel="icon" href="../favicon.ico" />
  </head>
  <body
    class="antialiased bg-neutral-950 text-neutral-200 font-sans selection:bg-neutral-800 selection:text-white"
  >
    <header class="border-b border-white/10">
      <div class="mx-auto max-w-3xl px-6 h-16 flex items-center justify-between">
        <a href="../index.html" class="text-sm text-neutral-300 hover:text-white">← Home</a>
        <span class="text-sm text-neutral-400">PS70 Fall 2025</span>
      </div>
    </header>
    <main class="mx-auto max-w-3xl px-6 py-10">
      <article class="prose prose-invert font-sans">
        <h1>Week 7 — Outputs: Find My BLE broadcasts on Flipper + ESP32</h1>

        <h2>Here's How It All Works</h2>
        <div class="mt-4 space-y-4">
          <a href="./architecture.png">
            <img src="./architecture.png" alt="Project data flow diagram for Find My broadcasts, relays, and retrieval web service" />
          </a>
        </div>
        <p class="mt-4">So here's the basic flow:</p>
        <ul>
          <li>Your device (Flipper or ESP32) sends out a special 31-byte Apple payload that includes part of your public key</li>
          <li>Any nearby iPhones, iPads, or Macs pick this up and anonymously send encrypted location reports to Apple</li>
          <li>Your web service asks Apple for reports matching your key, then decrypts them to show locations</li>
        </ul>

        <h3 class="mt-10">What you'll need</h3>
        <ul>
          <li>A computer running macOS, Linux, or Windows</li>
          <li>Python 3.9+ for the web service (I'd recommend using a virtual environment)</li>
          <li>A Flipper Zero (optional, but makes Part 1 way easier)</li>
          <li>An ESP32 DevKit (classic ESP32 like the ESP32-WROOM) for Part 2</li>
          <li>Some recent iPhones, iPads, or Macs nearby to act as location relays</li>
        </ul>

        <h2>Step 1 — Let's Start with the Flipper Zero</h2>
        <p>
          I always like to start with the quickest way to see results: get a working payload broadcasting and make sure nearby Apple devices are picking it up and sending reports. The plan is simple - generate some crypto keys, get that 31-byte Apple payload on the air, and see if the location reports start coming in.
        </p>

        <h3>1) Generate your keys</h3>
        <p>I used the project's key generator to create a SECP224R1 keypair. It spits out a <code>.keys</code> file with everything you need: your private key, the 28-byte advertisement key (that's the public X coordinate), a SHA-256 hash of it in Base64, and even a ready-to-use payload. This way you can test the radio stuff quickly without getting bogged down in firmware details right away.</p>
        <p>The script creates a <code>.keys</code> file in <code>AirTagGeneration/keys/</code> that contains:</p>
        <ul>
          <li>Your private key (in both Base64 and hex formats)</li>
          <li>The advertisement key/public key (also in Base64 and hex)</li>
          <li>A hashed version of the advertisement key (Base64 of the SHA-256)</li>
          <li>The derived MAC address and complete payload (in hex)</li>
        </ul>

        <h3>2) Get those keys on your Flipper</h3>
        <ul>
          <li>Just copy that <code>.keys</code> file over to <code>Apps_Data/FindMyFlipper</code> on your Flipper, or if you prefer, manually type in the MAC and Payload values using the FindMy app on the device.</li>
        </ul>

        <h3>3) Start broadcasting</h3>
        <ul>
          <li>Fire up the FindMy app on your Flipper and pick the tag you want to use. Make sure it's actually advertising (you should see some indication that it's working). Once that's going, any nearby Apple devices will catch the signal and start sending encrypted location reports to Apple.</li>
        </ul>

        <div class="flex flex-col mt-6">
          <a href="./flipper-settings.jpeg">
            <img src="./flipper-settings.jpeg" alt="Flipper FindMy settings page showing payload configuration" class="w-full" />
          </a>
          <a href="./flipper-broadcast.jpeg">
            <img src="./flipper-broadcast.jpeg" alt="Flipper FindMy app broadcasting a Find My payload" class="w-full" />
          </a>
        </div>

        <h3 class="mt-8">Quick validation checks</h3>
        <ul>
          <li>Use a BLE scanner app to confirm you can see the Apple Manufacturer data (look for Company ID 0x004C) and that 31-byte payload.</li>
          <li>Don't expect to see a friendly device name - this thing is just broadcasting, not acting like a normal Bluetooth device. It uses a static random address, so it'll look a bit mysterious.</li>
        </ul>

        <h3>Key generation core (Python)</h3>
        <div class="code-editor">
          <div class="code-editor-header">
            <div class="code-editor-dots">
              <span class="code-editor-dot red"></span>
              <span class="code-editor-dot yellow"></span>
              <span class="code-editor-dot green"></span>
            </div>
            <div class="code-editor-title">generate_keys.py</div>
            <div class="code-editor-actions">
              <button type="button" class="code-editor-copy" data-copy="#week7-code1">Copy</button>
            </div>
          </div>
          <div class="code-editor-body">
            <pre><code id="week7-code1" class="language-python">def advertisement_template():
    adv = ""
    adv += "1e"  # length (30)
    adv += "ff"  # manufacturer specific data
    adv += "4c00"  # company ID (Apple)
    adv += "1219"  # offline finding type and length
    adv += "00"  # state
    for _ in range(22):
        adv += "00"
    adv += "00"  # first two bits of key[0]
    adv += "00"  # hint
    return bytearray.fromhex(adv)

def generate_mac_and_payload(public_key):
    key = public_key.public_numbers().x.to_bytes(28, byteorder="big")
    addr = bytearray(key[:6])
    addr[0] |= 0b11000000
    adv = advertisement_template()
    adv[7:29] = key[6:28]
    adv[29] = key[0] >> 6
    return addr.hex(), adv.hex()</code></pre>
          </div>
        </div>

        <h2>Step 2 — Let's Make It Portable with ESP32</h2>
        <p>
          Now that we've got it working on the Flipper, let's move that same payload over to an ESP32 so it can run standalone and sip just a few milliamps of power. The Arduino sketch sends out the exact same Offline Finding broadcast using only your advertisement key. No fancy GATT server needed - just a straightforward advertiser that runs cleanly with good timing and proper state management.
        </p>

        <h3>What you need to configure</h3>
        <ul>
          <li>You'll need to set the advertisement key constant to your 28-byte public key (that's 56 hex characters):</li>
        </ul>
        <div class="code-editor">
          <div class="code-editor-header">
            <div class="code-editor-dots">
              <span class="code-editor-dot red"></span>
              <span class="code-editor-dot yellow"></span>
              <span class="code-editor-dot green"></span>
            </div>
            <div class="code-editor-title">ESP32FindMyFlipper.ino</div>
            <div class="code-editor-actions">
              <button type="button" class="code-editor-copy" data-copy="#week7-code2">Copy</button>
            </div>
          </div>
          <div class="code-editor-body">
            <pre><code id="week7-code2" class="language-cpp">// In ESP32FindMyFlipper/ESP32FindMyFlipper.ino
// Generated from `generate_keys.py`
const char* FINDMY_ADV_KEY_HEX = "&lt;YOUR_56_HEX_CHARS_ADVERTISEMENT_KEY&gt;";

// BLE specification constants
constexpr uint16_t BLE_COMPANY_ID_APPLE = 0x004C;
constexpr uint8_t BLE_ADV_TYPE_MANUFACTURER_SPECIFIC = 0xFF;
constexpr uint8_t BLE_ADV_OFFLINE_FINDING_TYPE = 0x12;
constexpr uint8_t BLE_ADV_OFFLINE_FINDING_LENGTH = 0x19;</code></pre>
          </div>
        </div>

        <h3>Getting it on your ESP32</h3>
        <p>
          To keep things simple while testing, I watched the serial monitor at 115200 baud and set the advertising interval to 1 second—this made it easy to track broadcasts in real time. The code is designed to wait until the Bluetooth controller is fully ready before starting setup, which helps prevent those pesky INIT/IDLE state errors.
        </p>

        <h3>A few things to know</h3>
        <ul>
          <li>The sketch fires up the BLE controller, builds that 31-byte payload, and starts advertising every second by default</li>
          <li>You can tweak the battery/status byte in the code to give hints about the device's state in the broadcast</li>
          <li>The MAC address is derived from your advertisement key but uses the static random format (so it starts with those C0 bits)</li>
        </ul>

        <h3>If things go wrong</h3>
        <ul>
          <li>If you see the BLE controller getting stuck in INIT/IDLE states in the logs, just power cycle the board and try again. Also double-check that your ESP32 board support is up to date.</li>
          <li>Make sure your advertisement key is exactly 56 hex characters - if it's off by even one character, you'll get an invalid broadcast frame.</li>
        </ul>

        <h3 class="mt-8">Verify it's working with nRF Connect (iOS)</h3>
        <ol>
          <li>Open up nRF Connect and go to the Scanner tab. Make sure Bluetooth is on and get close to your ESP32.</li>
          <li>Hit the filter icon and turn on "Manufacturer Specific Data". If you can filter by Company ID 0x004C (that's Apple), go for it.</li>
          <li>Look for a device that doesn't have a friendly name and keeps showing up with a static random address (it'll start with C0 or show as randomized). That's probably your device - tap on it.</li>
          <li>Check the Advertising Data section:
            <ul>
              <li>You should see Manufacturer Specific Data present</li>
              <li>Company Identifier should be 0x004C (Apple)</li>
              <li>Total payload length should be 31 bytes</li>
              <li>Look for type 0x12 and length 0x19 inside the Apple data block</li>
              <li>The 22 bytes in there should match <code>adv_key[6:28]</code> from your keys, plus the hint byte (top 2 bits of <code>adv_key[0]</code>)</li>
            </ul>
          </li>
          <li>Double-check against your <code>.keys</code> file:
            <ul>
              <li>The "Payload" hex should match exactly what the generator created</li>
              <li>The MAC address will be static random (not the same as your adv key bytes)</li>
            </ul>
          </li>
        </ol>
        <p class="mt-4 text-sm text-neutral-400">Pro tip: If you're using really fast advertising intervals, the app might miss some packets. A 1-second interval makes it much easier to see everything clearly.</p>

        <h2>Quick Break — 3D Printing an ESP32 Case</h2>
        <p>
          I whipped up a simple two-piece PLA case that holds an ESP32 dev board. No battery compartment yet, but it works great as a basic enclosure. You can attach it to a keyring, just make sure to keep the antenna area clear and avoid putting it near metal objects.
        </p>
        <h3>What I designed</h3>
        <ul>
          <li>Dimensions are sized for a standard ESP32-WROOM devkit (I added 1-2mm clearance just to be safe)</li>
          <li>Wall thickness is 1.6-2.0mm with 15% infill - that's plenty strong enough</li>
          <li>2.5-3.0mm standoffs to keep it clear of the solder joints, designed for M2 self-tapping screws</li>
          <li>4-5mm keyring hole with some reinforcement ribs so it doesn't break</li>
        </ul>
        <h3>Putting it together</h3>
        <ul>
          <li>Just print both halves and press-fit your ESP32 inside - no screws or anything fancy needed</li>
          <li>Make sure the USB-C or Micro-USB port lines up with the notch I designed</li>
        </ul>
        <h3>Download the files</h3>
        <ul>
          <li>Bottom carrier: <a href="./esp32-wroom-32d_carrier.stl" download>esp32-wroom-32d_carrier.stl</a></li>
          <li>Top cover: <a href="./esp32-wroom-32d_cover.stl" download>esp32-wroom-32d_cover.stl</a></li>
        </ul>

        <h3 class="mt-8">ESP32 Carrier</h3>
        <div class="aspect-video bg-black ring-1 ring-white/10 relative overflow-hidden rounded-lg">
          <iframe
            src="https://www.viewstl.com/?embedded&url=https%3A%2F%2Fgithub.com%2Ftheotarr%2Fps70%2Fraw%2Frefs%2Fheads%2Fmain%2F07_outputs%2Fesp32-wroom-32d_carrier.stl&color=white&bgcolor=black&shading=smooth&clean=yes&noborder=yes"
            allowfullscreen
            style="border: 0; margin: 0; width: 100%; height: 100%; display: block"
            loading="lazy"
            title="Interactive 3D — ESP32 Carrier"
          ></iframe>
        </div>

        <h3 class="mt-6">ESP32 Cover</h3>
        <div class="aspect-video bg-black ring-1 ring-white/10 relative overflow-hidden rounded-lg">
          <iframe
            src="https://www.viewstl.com/?embedded&url=https%3A%2F%2Fgithub.com%2Ftheotarr%2Fps70%2Fraw%2Frefs%2Fheads%2Fmain%2F07_outputs%2Fesp32-wroom-32d_cover.stl&color=white&bgcolor=black&shading=smooth&clean=yes&noborder=yes"
            allowfullscreen
            style="border: 0; margin: 0; width: 100%; height: 100%; display: block"
            loading="lazy"
            title="Interactive 3D — ESP32 Cover"
          ></iframe>
        </div>

        <h2>Step 3 — Building a Web Dashboard to See Your Locations</h2>
        <p>
          Getting your device to broadcast is cool, but the real magic happens when you can actually see those location dots on a map! This FastAPI web app handles all the authentication with Apple, queries for reports using your hashed keys, decrypts them with your private keys, and shows everything in a nice web interface with live updates.
        </p>
        <h3>Getting set up</h3>
        <div class="code-editor">
          <div class="code-editor-header">
            <div class="code-editor-dots">
              <span class="code-editor-dot red"></span>
              <span class="code-editor-dot yellow"></span>
              <span class="code-editor-dot green"></span>
            </div>
            <div class="code-editor-title">setup.sh</div>
            <div class="code-editor-actions">
              <button type="button" class="code-editor-copy" data-copy="#week7-code3">Copy</button>
            </div>
          </div>
          <div class="code-editor-body">
            <pre><code id="week7-code3" class="language-bash">cd AirTagGeneration
python3 -m venv venv
source venv/bin/activate
pip install -r requirements.txt</code></pre>
          </div>
        </div>
        <h4>Authentication setup</h4>
        <ul>
          <li>The service uses <code>request_reports.getAuth()</code> which needs valid Apple account credentials (those special anisette headers and tokens). You'll need to provide either a <code>keys/auth.json</code> file or set up environment variables depending on how you want to authenticate.</li>
        </ul>
        <h3>Starting the server</h3>
        <div class="code-editor">
          <div class="code-editor-header">
            <div class="code-editor-dots">
              <span class="code-editor-dot red"></span>
              <span class="code-editor-dot yellow"></span>
              <span class="code-editor-dot green"></span>
            </div>
            <div class="code-editor-title">run_server.sh</div>
            <div class="code-editor-actions">
              <button type="button" class="code-editor-copy" data-copy="#week7-code4">Copy</button>
            </div>
          </div>
          <div class="code-editor-body">
            <pre><code id="week7-code4" class="language-bash">uvicorn web_service:app --reload</code></pre>
          </div>
        </div>
        <p>Once it's running, open your browser and go to <code>http://localhost:8000</code> to see the interface.</p>
        <h4>Where it stores data</h4>
        <ul>
          <li>Everything goes into a local SQLite database at <code>AirTagGeneration/keys/reports.db</code> (it creates this automatically). The <code>tags</code> table keeps track of all your device info like private keys, hashed advertisement keys, and any MQTT settings you might want.</li>
        </ul>
        <h4>Live updates</h4>
        <ul>
          <li>The web app sends live updates using server-sent events, so your map refreshes automatically whenever new location reports come in.</li>
        </ul>

        <div class="mt-6">
          <a href="./map-tags.jpeg">
            <img src="./map-tags.jpeg" alt="Map UI showing decrypted tag locations" />
          </a>
        </div>
        <p class="mt-2 text-sm text-neutral-400 italic">* Fun fact: that's actually me hanging out in my dorm (Lionel) in the yard while testing this whole location tracking thing.</p>
        <div class="mt-6">
          <a href="./manage-tags.jpeg">
            <img src="./manage-tags.jpeg" alt="Manage tags UI to add private key and hashed advertisement key" />
          </a>
        </div>

        <div class="mt-6">
          <a href="./findmy-api-specs.jpeg">
            <img src="./findmy-api-specs.jpeg" alt="Reference: Find My API frame structure and fields" />
          </a>
        </div>

        <h3 class="mt-8">The API Endpoints</h3>
        <p>The web dashboard also gives you a simple HTTP API for managing your devices and getting location data, plus a live event stream for real-time updates. When it talks to Apple's servers, it uses those special authentication headers and tokens, but locally it only keeps your private keys and the decrypted location reports.</p>
        <ul>
          <li><code>GET /api/tags</code>: see all your configured devices (shows hashed keys and other metadata)</li>
          <li><code>POST /api/tags</code>: add a new device or update an existing one with its private key and hashed advertisement key</li>
          <li><code>GET /api/reports?hash=&lt;base64_sha256_adv_key&gt;</code>: get the decrypted location reports for a specific device</li>
          <li><code>GET /events</code>: live event stream that pushes location updates as they arrive</li>
        </ul>
        <p><strong>The cool part about the architecture:</strong> I designed this so the Apple communication is completely separate from data storage and transport. You could easily swap in a mock Apple client for testing, send updates to MQTT or webhooks, or add different permission levels per device. This setup makes it totally possible to build your own "Find My"-style service without ever touching the Bluetooth broadcast format.</p>

        <h3 class="mt-8">Snippet: FastAPI event broadcaster (Python)</h3>
        <div class="code-editor">
          <div class="code-editor-header">
            <div class="code-editor-dots">
              <span class="code-editor-dot red"></span>
              <span class="code-editor-dot yellow"></span>
              <span class="code-editor-dot green"></span>
            </div>
            <div class="code-editor-title">web_service.py</div>
            <div class="code-editor-actions">
              <button type="button" class="code-editor-copy" data-copy="#week7-code5">Copy</button>
            </div>
          </div>
          <div class="code-editor-body">
            <pre><code id="week7-code5" class="language-python">class EventBroadcaster:
    def __init__(self):
        self.connections: Set[asyncio.Queue] = set()
        self.lock = asyncio.Lock()
    async def connect(self) -> asyncio.Queue:
        queue = asyncio.Queue()
        async with self.lock:
            self.connections.add(queue)
        return queue
    async def disconnect(self, queue: asyncio.Queue):
        async with self.lock:
            self.connections.discard(queue)
    async def broadcast(self, event: str, data: Any):
        message = f"event: {event}\ndata: {json.dumps(data, separators=(',', ':'))}\n\n"
        async with self.lock:
            disconnected = set()
            for queue in self.connections:
                try:
                    await queue.put(message)
                except Exception:
                    disconnected.add(queue)
            self.connections -= disconnected</code></pre>
          </div>
        </div>

        <h2>Understanding How Apple's Find My Network Actually Works</h2>
        <h3>The Bluetooth packet structure we're using</h3>
        <ul>
          <li>It's sent as Manufacturer Specific Data (that's Bluetooth advertising type 0xFF)</li>
          <li>Company ID is set to Apple (0x004C)</li>
          <li>Uses Apple's special "Offline Finding" frame type (0x12)</li>
          <li>The Offline Finding part is 0x19 (25) bytes long</li>
          <li>Total payload comes out to exactly 31 bytes</li>
        </ul>
        <h4>How we hide the 28-byte advertisement key in there</h4>
        <ul>
          <li>Bytes 7-28 of the payload contain <code>adv_key[6:28]</code> (22 bytes of your public key)</li>
          <li>Byte 29 holds the top two bits of <code>adv_key[0]</code> (like a little hint field)</li>
          <li>Byte 0 can show battery level or status, depending on how you configure your device</li>
        </ul>
        <h4>About the MAC address</h4>
        <ul>
          <li>Your device uses a static random address made from the first bytes of your advertisement key (with those special C0 bits set)</li>
          <li>This way we don't expose the raw public key as the device address, but it's still consistent enough that other devices can track it</li>
        </ul>



        <h3 class="mt-10">The Complete Flow (How This All Works Together)</h3>
        <ol>
          <li>Create a SECP224R1 keypair - that 28-byte public X coordinate becomes your "advertisement key"</li>
          <li>Broadcast the 31-byte payload over Bluetooth with Apple's Company ID and the Offline Finding frame type</li>
          <li>Any nearby iPhones, iPads, or Macs hear this and anonymously upload encrypted location reports to Apple</li>
          <li>Your web service logs into Apple, asks for reports matching your hashed advertisement key (that's Base64 of the SHA-256 of your 28-byte key), and gets back encrypted location data</li>
          <li>You use your private key to decrypt those reports locally, then save everything to SQLite and display it in the web interface</li>
        </ol>

        <h3>Important notes about security and ethics</h3>
        <ul>
          <li>Make sure to use your own Apple account and devices only. Follow local laws and Apple's terms of service. This is purely for educational and research purposes.</li>
          <li>In real Apple devices, they rotate identifiers to protect privacy - this demo uses the OpenHaystack approach with static keys, which is totally fine for learning but not how production devices work.</li>
        </ul>

        <h2 class="mt-12">When Things Don't Work (Troubleshooting)</h2>
        <ul>
          <li><strong>ESP32 upload problems:</strong> Double-check your board settings and serial port (try <code>arduino-cli board list</code>), and don't forget to use the BOOT and EN buttons if your board needs them.</li>
          <li><strong>No location dots showing up:</strong> Make sure there are iOS devices nearby that are signed into iCloud. Verify your hashed advertisement key exactly matches what's in your <code>.keys</code> file. Sometimes you just need to wait a bit and move around to different locations.</li>
          <li><strong>BLE scanner doesn't show a device name:</strong> That's totally normal! Just check that you can see the Manufacturer Data (0x004C) and that the payload is 31 bytes long.</li>
          <li><strong>Web service authentication failing:</strong> Make sure your anisette headers and authentication are working properly - check the server logs for specific error messages.</li>
        </ul>

        <h2>Appendix — File Structure</h2>
        <ul>
          <li>ESP32 Arduino sketch: <code>ESP32FindMyFlipper/ESP32FindMyFlipper.ino</code></li>
          <li>Key generation script: <code>AirTagGeneration/generate_keys.py</code></li>
          <li>Web dashboard: <code>AirTagGeneration/web_service.py</code></li>
          <li>Local database: <code>AirTagGeneration/keys/reports.db</code> (SQLite)</li>
        </ul>

        <h3>ESP32 Deep Dive (How the Bluetooth advertising actually works)</h3>
        <ul>
          <li>The state machine waits for the Bluetooth controller to be fully enabled before setting up advertising - it retries automatically if it gets stuck in INIT or IDLE states</li>
          <li>Advertising timing can range from 20 milliseconds to 10.24 seconds - I default to about 1 second. Going too fast wastes battery and creates radio interference</li>
          <li>The payload gets built by putting Apple's Company ID (0x004C), the Offline Finding type (0x12), length (0x19), and then all the derived fields that embed your 28-byte advertisement key</li>
          <li>The MAC address is static random (derived from your adv key with those C0 bits) - this is completely separate from the Apple payload data</li>
        </ul>

        <h3>Web Dashboard Deep Dive</h3>
        <ul>
          <li>FastAPI serves the HTML pages and uses Server-Sent Events to push live location updates</li>
          <li>The SQLite database has a <code>tags</code> table that stores <code>hash_adv_key</code>, <code>private_key</code>, and any optional MQTT configuration</li>
          <li>There's a background scheduler that queries Apple, decrypts reports with your private key, saves them to the database, and streams updates to connected clients</li>
        </ul>

        <h3>Resources I found helpful</h3>
        <ul>
          <li><a href="https://positive.security/blog/send-my" target="_blank" rel="noopener">Positive Security's "Send My: Arbitrary data transmission via Apple's Find My network"</a> - this was my main reference</li>
        </ul>

        <h3>Ideas for future improvements</h3>
        <ul>
          <li><strong>Hide data in the MAC address:</strong> Play around with encoding information in the static random address (while staying within Bluetooth address rules). See how well it gets relayed and if there are any deduplication issues</li>
          <li><strong>Better ESP32 case:</strong> Add a battery compartment (CR2032 or LiPo), a power switch, and a proper strain-relieved keyring attachment. Keep metal away from the antenna area</li>
          <li><strong>Even smaller devices:</strong> Look into nRF52, ESP32-C3, or custom Nordic chips. For coin cell batteries, you'd need longer advertising intervals and smarter power management with sleep modes</li>
        </ul>
      </article>
      <nav class="mt-12 flex justify-between text-sm text-neutral-400">
        <a class="hover:text-white" href="../06_inputs/index.html">← Prev</a>
        <a class="hover:text-white" href="../08_cnc/index.html">Next →</a>
      </nav>
    </main>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/cpp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/bash.min.js"></script>
    <script>
      document.addEventListener("DOMContentLoaded", function () {
        if (window.hljs) {
          hljs.highlightAll();
        }

        var copyButtons = document.querySelectorAll(".code-editor-copy");
        copyButtons.forEach(function (btn) {
          btn.addEventListener("click", function () {
            var targetSelector = btn.getAttribute("data-copy");
            var codeEl = document.querySelector(targetSelector);
            if (!codeEl) return;
            var text = codeEl.innerText;
            if (navigator.clipboard && navigator.clipboard.writeText) {
              navigator.clipboard.writeText(text).then(function () {
                var original = btn.textContent;
                btn.textContent = "Copied!";
                setTimeout(function () {
                  btn.textContent = original;
                }, 1200);
              });
            } else {
              var textarea = document.createElement("textarea");
              textarea.value = text;
              document.body.appendChild(textarea);
              textarea.select();
              try {
                document.execCommand("copy");
              } catch (e) {}
              document.body.removeChild(textarea);
              var original = btn.textContent;
              btn.textContent = "Copied!";
              setTimeout(function () {
                btn.textContent = original;
              }, 1200);
            }
          });
        });
      });
    </script>
  </body>
</html>

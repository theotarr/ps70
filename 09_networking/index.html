<!doctype html>
<html lang="en" class="dark">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>PS70 — Week 9: Networking</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap"
      rel="stylesheet"
    />
    <link href="../dist/output.css" rel="stylesheet" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark-dimmed.min.css"
    />
    <link rel="icon" href="../favicon.ico" />
  </head>
  <body
    class="antialiased bg-neutral-950 text-neutral-200 font-sans selection:bg-neutral-800 selection:text-white"
  >
    <header class="border-b border-white/10">
      <div class="mx-auto max-w-3xl px-6 h-16 flex items-center justify-between">
        <a href="../index.html" class="text-sm text-neutral-300 hover:text-white">← Back to home</a>
        <span class="text-sm text-neutral-400">PS70 Fall 2025</span>
      </div>
    </header>
    <main class="mx-auto max-w-3xl px-6 py-10">
      <article class="prose prose-invert font-sans">
        <h1>Week 9 — Networking: Reusing Find My BLE</h1>
        <p>
          For networking this week, I reused the same Find My BLE configuration from Week 7 and my
          Final Project: devices broadcast the 31‑byte Apple Offline Finding payload; nearby Apple
          devices relay encrypted reports; my FastAPI dashboard authenticates, retrieves, decrypts,
          stores in SQLite, and streams live updates to the browser.
        </p>

        <h2>Architecture</h2>
        <div class="mt-4 space-y-4">
          <a href="../07_outputs/architecture.png">
            <img
              src="../07_outputs/architecture.png"
              alt="Networking architecture: device → Apple → web service → browser"
            />
          </a>
        </div>
        <ul>
          <li>ESP32 advertises a 31‑byte Apple 0x004C Offline Finding frame</li>
          <li>Nearby iOS/macOS devices relay encrypted location reports to Apple</li>
          <li>
            FastAPI service authenticates, requests reports for my hashed adv keys, and decrypts
          </li>
          <li>SQLite persists data; Server‑Sent Events push live updates to the browser</li>
        </ul>

        <h2>How Apple Offline Finding works</h2>
        <ol>
          <li>
            Pairing derives an EC keypair (SECP224R1); the public key (rolling) stays with the
            device.
          </li>
          <li>
            Every ~2 seconds the device advertises a 31‑byte BLE frame with a rolling public key.
          </li>
          <li>
            Nearby iOS/macOS devices encrypt their location to that key and upload reports to Apple.
          </li>
          <li>
            The owner computes the set of rolling keys for a time window and queries by their
            SHA‑256 hashes.
          </li>
          <li>
            The owner decrypts location reports locally; Apple can’t read plaintext locations.
          </li>
        </ol>

        <h3 class="mt-6">Encoder/Decoder</h3>
        <div class="mt-2 space-y-4">
          <figure>
            <img
              src="./modem.gif"
              alt="ESP32 modem: encoding messages into Find My rotating keys"
              class="w-full rounded-lg ring-1 ring-white/10"
            />
            <figcaption class="text-sm text-neutral-400 mt-2">
              ESP32 modem concept: bytes → rotating keys → 31‑byte Offline Finding frames.
            </figcaption>
          </figure>
        </div>

        <h2>Data Exfiltration Protocol</h2>
        <p>
          Following <a href="https://positive.security/blog/send-my">Positive Security</a>, the
          Apple backend can be modeled as a public key‑value store keyed by
          <code>SHA‑256(adv_public_key)</code>. Finder devices “write” by uploading reports for the
          encountered key; a receiver “reads” by probing for those key hashes. By agreeing on how to
          map bits/bytes to public keys, we can transmit tiny messages over time without direct
          internet.
        </p>
        <h3>Encoding scheme (bit‑wise, order‑independent)</h3>
        <ul>
          <li>
            Treat each advertisement as carrying one bit plus metadata to allow out‑of‑order
            assembly.
          </li>
          <li>
            Derive a 28‑byte payload that becomes (or derives) the EC public key used in the BLE
            frame.
          </li>
          <li>Include fields to disambiguate streams and positions: index, messageId, modemId.</li>
        </ul>
        <p class="text-sm text-neutral-400">
          Conceptual 28‑byte layout embedded/derived in the advertised key:
        </p>
        <pre><code>[4B bit_index][4B message_id][4B modem_id][padding 0s …][1B bit_value]</code></pre>
        <ul>
          <li>
            For each bit position, generate two candidate keys (value 0 and 1). Only one is
            broadcast.
          </li>
          <li>
            On retrieval, query both candidate hashes per position to recover the bit without
            relying on order.
          </li>
          <li>
            Byte‑wise encoding is possible but requires probing up to 256 key‑ids per byte on
            retrieval.
          </li>
          <li>
            Add light redundancy (repeats or parity per block) to cope with missing bits in noisy
            environments.
          </li>
        </ul>

        <h2>Implementation details</h2>
        <h3>Sending side (ESP32)</h3>
        <ul>
          <li>
            Generate/rotate keys and build the standard 31‑byte Apple <code>0x004C</code> Offline
            Finding frame.
          </li>
          <li>
            Map message bits to derived public keys that encode <em>bit_index</em>,
            <em>message_id</em>, <em>modem_id</em>.
          </li>
          <li>
            Advertise at modest intervals (~1–2s) to avoid radio spam and improve pickup
            probability.
          </li>
        </ul>
        <h3>Retrieval side (my FastAPI service)</h3>
        <ul>
          <li>
            Server computes expected rolling keys for a time window (OpenHaystack primitives).
          </li>
          <li>Compute key hashes, request any matching reports from Apple, and decrypt locally.</li>
          <li>
            Reassemble bits out‑of‑order using <em>bit_index</em>; persist to SQLite; stream via SSE
            to the UI.
          </li>
          <li>
            No Apple Mail plugin UI here; this uses my FastAPI backend integrated with the existing
            dashboard.
          </li>
        </ul>

        <h2>Planned PoC: Light sensor → encoded in payload</h2>
        <p>
          For a planned proof of concept, I will wire a photoresistor (voltage divider) to an ESP32
          ADC pin and quantized the reading into 4 bits. I then reuse the payload's status byte to
          carry that value. The goal is for nearby Apple devices to relay reports that my server can
          retrieve and decode to display an approximate light level.
        </p>
        <h3>ESP32 wiring</h3>
        <ul>
          <li>Photoresistor + 10kΩ forms a divider between 3.3V and GND</li>
          <li>Middle node → <code>GPIO34</code> (ADC)</li>
          <li>Common GND with ESP32</li>
        </ul>
        <h3>Firmware snippet (Arduino/ESP32)</h3>
        <p class="text-sm text-neutral-400">Inside your advertising payload builder/update loop:</p>
        <pre><code class="language-cpp">// Read light and quantize to 4 bits
int raw = analogRead(34);              // 0..4095 on many ESP32 boards
int q   = map(raw, 0, 4095, 0, 15);    // 0..15

// Build a status byte: high nibble = type (0x1 = light), low nibble = value
uint8_t status = (0x1 &lt;&lt; 4) | (q &amp; 0x0F);

// Place into the Offline Finding payload
// adv[0] is the state/status byte in the 31-byte Apple payload
adv[0] = status;

// Re-start (or update) advertising with the modified payload</code></pre>

        <h3>Server-side decode (Python)</h3>
        <p>When parsing reports, read the first payload byte to recover the light nibble:</p>
        <pre><code class="language-python">def decode_status_byte(payload_bytes: bytes):
    status = payload_bytes[0]
    msg_type = (status &amp; 0xF0) &gt;&gt; 4
    value_nibble = status &amp; 0x0F
    if msg_type == 0x1:
        # Convert 0..15 back to an approximate raw range (illustrative)
        approx_raw = int(value_nibble / 15.0 * 4095)
        return {"type": "light", "q4": value_nibble, "approx_raw": approx_raw}
    return {"type": "unknown", "raw": status}</code></pre>

        <h2>Public key validity</h2>
        <p>
          Not every 28‑byte SEC1 X‑coordinate represents a valid point on P‑224. Finder devices
          reject invalid points, so those broadcasts never yield reports. Two possible remedies are:
        </p>
        <ol>
          <li>
            <strong>Deterministic validity probing</strong>: before broadcasting, check if the EC
            point is valid; if not, increment a counter/nonce and retry until valid. The receiver
            mirrors this process to derive the same key sequence deterministically.
          </li>
          <li>
            <strong>Treat payload as a private key</strong>: derive the public key via scalar
            multiplication (always yields a valid point). Practical library differences on
            microcontrollers can cause mismatches; for this PoC I use option (1).
          </li>
        </ol>

        <h2>Testing and performance</h2>
        <ul>
          <li>
            <strong>Send rate (MCU)</strong>: ~3 bytes/second with simple firmware (can be higher
            with caching/byte encoding).
          </li>
          <li>
            <strong>Receive rate (Mac/server)</strong>: ~16 bytes per ~5 seconds per request batch.
          </li>
          <li>
            <strong>Latency</strong>: typically 1–60 minutes depending on finder
            density/connectivity; the first uploaded report suffices to recover a bit.
          </li>
        </ul>

        <h2 class="mt-10">Next steps</h2>
        <ul>
          <li>Get the PoC IOT light sensor working on breadboard</li>
          <li>
            Extend server UI to display decode messages and IoT sensor readings alongside locations
          </li>
        </ul>
      </article>
      <nav class="mt-12 flex justify-between text-sm text-neutral-400">
        <a class="hover:text-white" href="../08_cnc/index.html">← Prev</a>
        <a class="hover:text-white" href="../10_machine/index.html">Next →</a>
      </nav>
    </main>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/cpp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/bash.min.js"></script>
    <script>
      document.addEventListener("DOMContentLoaded", function () {
        if (window.hljs) {
          hljs.highlightAll();
        }
      });
    </script>
  </body>
</html>
